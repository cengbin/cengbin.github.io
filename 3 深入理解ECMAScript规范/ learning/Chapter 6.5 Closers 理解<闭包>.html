<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>理解闭包</title>
  </head>
</html>
<script>
  // 实际上，闭包是方法代码和他的[[Scope]]属性的集合。

  function func1() {
    let beijing = 'beijing'

    function func2() {
      let shanghai = 'shanghai'
      let hangzhou = 'hangzhou'
      let hongkong = 'hongkong'

      // JavaScript 除了静态作用域链外，还有一个特点就是函数可以作为返回值。
      // 此处把 func3 作为返回值
      function func3() {
        let chengdu = 'chengdu'

        // 第1种情况：
        // 在函数创建阶段：由于内部函数引用了外部变量，JS引擎会做AST扫描，会分析得出func3函数用到了哪些外部引用，然后把这些外部引用打包成Closure闭包，加到func3函数的[[Scopes]]属性中。
        // func3函数创建时的 [[Scopes]] = [
        //    0: Closure (func1) {beijing: 'beijing'}
        //    1: Script {func2: ƒ, func3: ƒ}
        //    2: Global {window: Window, self: Window, document: document, name: '', location: Location, …}
        // ]
        console.log(beijing)

        /*// 第2种情况：
        // 在函数创建阶段：由于code值是动态的(执行的时候才知道值是什么)，没法分析外部引用，也就没法打包闭包，这种就特殊处理一下，打包整个作用域就好了。
        // 此时func3的 [[Scopes]] = [
        //    0: Closure (func2) {shanghai: 'shanghai', hangzhou: 'hangzhou', shenzheng: 'shengzheng', arguments: Arguments(0), func3: ƒ}
        //    1: Closure (func1) {beijing: 'beijing', arguments: Arguments(0), func2: ƒ}
        //    2: Script {func2: ƒ, func3: ƒ}
        //    3: Global {window: Window, self: Window, document: document, name: '', location: Location, …}
        // ]
        let code = `console.log(beijing,shanghai,chengdu);`
        // let code = `console.log(chengdu);`
        // let code = `console.log(1);`*/
      }

      return func3
    }

    return func2
  }

  let func2 = func1()
  let func3 = func2()

  func3()
</script>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Title</title>
  </head>
  <body>

  </body>
</html>

<!--<script>
  // 创建A函数（A函数创建完成后，A函数本身也是一个对象）
  function A() {

  }

  // 在创建函数对象的算法中可以看到，在创建函数时，constructor属性被设置为函数的prototype的属性。
  // 这个属性的值是对函数本身的循环引用:
  console.log(A.prototype.constructor)

  var a = new A()
  console.log(a)
  console.log(a.constructor) // A函数
  console.log(a.constructor === A) // true
  console.log(`\n`)

  // 通常在这种情况下，存在着一个误区：constructor 属性属于原型,并非属于新创建对象a自身的属性。这个属性通过继承来访问。
  console.log(a.hasOwnProperty('constructor')) // false
  console.log(a.__proto__.hasOwnProperty('constructor')) // true
  console.log(`\n`)

  A.prototype.x = new Number(10)
  console.log(A.prototype) // {x: Number, constructor: ƒ}

  // 通过继承来的constructor属性，可以间接得到的原型对象的引用：
  console.log(a.constructor.prototype) // {x: Number, constructor: ƒ}
  console.log(A.prototype === a.constructor.prototype) // true
  console.log(`\n`)
</script>-->

<!--<script>
  function A() {

  }

  A.prototype.x = new Number(10)

  var a = new A()
  console.log(a.x) // Number
  console.log(a.constructor === A) // true
  console.log(a.constructor === Object.prototype.constructor) // false

  for (var k in A.prototype) {
    console.log(k) // only "x"
  }
</script>-->

<!--<script>
  function A() {

  }

  // 函数的prototype属性在对象创建以后都可以重新定义的。
  A.prototype = {
    x: 10
  }

  var a = new A()
  console.log(a.x) // 10
  // 我们彻底改变函数的prototype属性（通过分配一个新的对象），
  // 那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：
  console.log(a.constructor === A) // false
  console.log(a.constructor === Object.prototype.constructor) // true
</script>-->

<script>
  function A() {

  }

  // 对函数的原型引用需要手工恢复：
  A.prototype = {
    constructor: A,
    x: 10
  }

  var a = new A()
  console.log(a.x) // 10
  console.log(a.constructor === A) // true
  console.log(a.constructor === Object.prototype.constructor) // false

  for (var k in A.prototype) {
    console.log(k) // "constructor", "x"
  }
</script>

<!--<script>
  function A(x) {
    this.x = x || 10
  }

  var a = new A
  console.log(a.x)

  var b = new A(20)
  console.log(b.x)
</script>-->

<!--<script>
  function A(x) {

  }

  A.prototype.x = 10

  var a = new A
  console.log(a.x) // 10 - 从原型上得到

  // 设置.prototype属性为新对象
  A.prototype = {
    constructor: A,
    y: 100
  }

  var b = new A()
  // 对象"b"有了新属性
  console.log(b.x) // undefined
  console.log(b.y) // 100 - 从原型上得到

  // 但是a对象的原型依然可以得到原来的结果
  console.log(a.x) // 10 - 从原型上得到
  console.log('\n')

  function B() {
    this.x = 10
    return new Array()
  }

  // 如果"B"构造函数没有返回（或返回this）
  // 那么this对象就可以使用，但是下面的情况返回的是array
  var b = new B
  console.log(b.x) // undefined
  console.log(Object.prototype.toString.call(b)) // [object Array]

</script>-->

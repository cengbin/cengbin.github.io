# CSS与JS是这样阻塞DOM解析和渲染

## CSS

1. CSS下载不会阻塞DOM解析
2. CSS下载阻塞页面渲染
	- 这个策略其实很明智的，想象一下，如果没有这个策略，页面首先会呈现出一个原始的模样，待CSS下载完之后又突然变了一个模样。用户体验可谓极差，而且渲染是有成本的。
3. 如果`<script/>`在`<link/>`之后， CSS下载阻塞JS执行，只有等CSS下载完成后JS才会执行
	- `<header>`
	- `<link rel="stylesheet" href="/css/sleep3000-common.css">`
	- `<script src="/js/logDiv.js"></script>`
	- `</header>`
	- 仔细思考一下，其实这样做是有道理的，如果脚本的内容是获取元素的样式，宽高等CSS控制的属性，浏览器是需要计算的，也就是依赖于CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行JS。因而造成了之前例子的情况。
	- 所以，看官大人明白为何`<script>`与`<link>`同时在头部的话，`<script>`在上可能会更好了么？之所以是可能，是因为如果`<link>`的内容下载更快的话，是没影响的，但反过来的话，JS就要等待了，然而这些等待的时间是完全不必要的。
4. CSS不阻塞外部脚本的并发加载

## JS

1. JS下载/执行 阻塞DOM解析和渲染
	- 浏览器并不知道脚本的内容是什么，如果先行解析下面的DOM，万一脚本内全删了后面的DOM，浏览器就白干活了。更别谈丧心病狂的document.write。浏览器无法预估里面的内容，那就干脆全部停住，等脚本执行完再干活就好了。

	- 当然，现代的浏览器很聪明，它会“偷看”之后的DOM内容，碰到如`<link>`、`<script>`和`<img>`等标签时，它会帮助我们先行下载里面的资源，不会傻等到解析到那里时才下载。

2. 浏览器遇到 `<script>` 标签时，会触发页面渲染
	- 浏览器每次event loop其实是做了三件事,宏任务 —  微任务  —  页面渲染
	- 以此循环，所以每一个script作为一个宏任务，每次script都会触发一次页面的渲染。

## 小结

综上所述，我们得出这样的结论：

* CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。
* JS 阻塞 DOM 解析，但浏览器会"偷看"DOM，预先下载相关资源。
* 浏览器遇到 `<script>`且没有defer或async属性的 标签时，会触发页面渲染，因而如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。
import{_ as e,o as t,c as a,Q as r}from"./chunks/framework.6ae5a3d9.js";const m=JSON.parse('{"title":"虚拟列表技术","description":"","frontmatter":{},"headers":[],"relativePath":"7 虚拟列表技术/README.md","filePath":"7 虚拟列表技术/README.md"}'),o={name:"7 虚拟列表技术/README.md"},s=r('<h1 id="虚拟列表技术" tabindex="-1">虚拟列表技术 <a class="header-anchor" href="#虚拟列表技术" aria-label="Permalink to &quot;虚拟列表技术&quot;">​</a></h1><p>虚拟列表是指对列表的“可视区域”进行渲染，对“非可见区域”不渲染或部分渲染，从而极大提高渲染性能的一种技术。</p><h3 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h3><p>要实现一个下拉选择商家组件，要在下拉列表中展示一万条商家数据。</p><h3 id="实现思路" tabindex="-1">实现思路 <a class="header-anchor" href="#实现思路" aria-label="Permalink to &quot;实现思路&quot;">​</a></h3><p>已知条件：</p><ol><li>有10000条数据。</li><li>下拉的窗口宽高<code>100*400</code>。</li><li>下拉项宽<code>100*50</code>。</li></ol><p>思路：</p><p>监听视窗滚动事件，只渲染视窗可视区域的数据。为了避免出现滚动时数据闪现，上下分别多显示一条数据。</p><p>利用div的padding特性，当前内容区域的渲染总高度= 已渲染的高度 + 上边距 + 下边距</p><p>已渲染的高度浏览器自动计算，上边距=(startIndex - 0) * rowHeight，下边距= (this.data.length - endIndex) * rowHeight</p><p>计算startIndex： 等于滚动条的scrollTop除以每一行高度。startIndex = parseInt(scrollTop / rowHeight) 计算endIndex： 等于(startIndex + visibleCount)</p><p>计算当前渲染的数据：this.renderGoodsList = this.goodsList.slice(this.startIndex, this.endIndex)</p><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><p>Vue 插槽：<a href="https://v2.cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noreferrer">https://v2.cn.vuejs.org/v2/guide/components-slots.html</a></p><p>Vue Virtual Scroller：<a href="https://github.com/Akryum/vue-virtual-scroller/tree/v1/packages/vue-virtual-scroller" target="_blank" rel="noreferrer">https://github.com/Akryum/vue-virtual-scroller/tree/v1/packages/vue-virtual-scroller</a></p>',16),l=[s];function i(n,d,c,h,p,u){return t(),a("div",null,l)}const v=e(o,[["render",i]]);export{m as __pageData,v as default};

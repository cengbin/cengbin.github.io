import{_ as r,o,c as t,k as e,a}from"./chunks/framework.6ae5a3d9.js";const P=JSON.parse('{"title":"为什么Vue3要改用Proxy？","description":"","frontmatter":{},"headers":[],"relativePath":"51 面试/2. 原理、算法/Vue/为什么Vue3要改用Proxy.md","filePath":"51 面试/2. 原理、算法/Vue/为什么Vue3要改用Proxy.md"}'),u={name:"51 面试/2. 原理、算法/Vue/为什么Vue3要改用Proxy.md"},l=e("h1",{id:"为什么vue3要改用proxy",tabindex:"-1"},[a("为什么Vue3要改用Proxy？ "),e("a",{class:"header-anchor",href:"#为什么vue3要改用proxy","aria-label":'Permalink to "为什么Vue3要改用Proxy？"'},"​")],-1),n=e("ol",null,[e("li",null,"可以用Proxy检测对象新添加的属性，让他反应过来。（Vue2+只能通过Vue.set(obj,key,value)来添加新的响应式的属性）。"),e("li",null,"同样是适用于数组对象，（Vue2+改写了Array.prototype,对它做了代理所以当调用array.push,array.pop，改变数据长度等等的方法或操作的时候可以做到视图响应。注意：改变原生对象的prototype是不推荐，且需要谨慎的事情！），使用Proxy代理数组就能够监听到数组的变化。"),e("li",null,"proxy比defineProperty强大了太多，不仅解决了vue的历史难题，让vue的体验更上了一层，更是去除了不少因为defineProperty、Array.prototy代理而必须要的方法，精简了vue的包大小。"),e("li",null,"摆脱Vue目前的警告。（动态给对象添加属性，不用显示的告诉Vue您正在添加属性，你想让它反应过来）")],-1),s=[l,n];function p(i,_,c,y,d,x){return o(),t("div",null,s)}const h=r(u,[["render",p]]);export{P as __pageData,h as default};

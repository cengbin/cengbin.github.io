import{_ as e,o as a,c as n,Q as s}from"./chunks/framework.2eebfdfc.js";const g=JSON.parse('{"title":"如何在 Web 关闭页面时发送 Ajax 请求","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/18 如何在Web关闭页面时发送请求/README.md","filePath":"frontend/18 如何在Web关闭页面时发送请求/README.md"}'),t={name:"frontend/18 如何在Web关闭页面时发送请求/README.md"},o=s(`<h1 id="如何在-web-关闭页面时发送-ajax-请求" tabindex="-1">如何在 Web 关闭页面时发送 Ajax 请求 <a class="header-anchor" href="#如何在-web-关闭页面时发送-ajax-请求" aria-label="Permalink to &quot;如何在 Web 关闭页面时发送 Ajax 请求&quot;">​</a></h1><h2 id="_1-事件监听" tabindex="-1">1.事件监听 <a class="header-anchor" href="#_1-事件监听" aria-label="Permalink to &quot;1.事件监听&quot;">​</a></h2><p>浏览器有两个事件可以用来监听页面关闭，beforeunload和unload</p><h3 id="beforeunload事件mdn" tabindex="-1">beforeunload事件<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/beforeunload" target="_blank" rel="noreferrer">MDN</a> <a class="header-anchor" href="#beforeunload事件mdn" aria-label="Permalink to &quot;beforeunload事件[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Events/beforeunload)&quot;">​</a></h3><p>当浏览器窗口关闭或者刷新时，会触发beforeunload事件。当前页面不会直接关闭，可以点击确定按钮关闭或刷新，也可以取消关闭或刷新。</p><p>如果处理函数为Event对象的returnValue属性赋值非空字符串，浏览器会弹出一个对话框，来询问用户是否确定要离开当前页面（如下示例）。有些浏览器会将返回的字符串展示在弹框里，但有些其他浏览器只展示它们自定义的信息。没有赋值时，该事件不做任何响应。</p><blockquote><p><label style="background-color:#fff3d4;">注：为了避免不必要的弹窗，如果页面并没有发生交互浏览器可能不会展示在 beforeunload 事件中引发的弹框，甚至可能即使发生交互了也直接不显示。</label></p></blockquote><h3 id="unload事件mdn" tabindex="-1">unload事件<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/unload" target="_blank" rel="noreferrer">MDN</a> <a class="header-anchor" href="#unload事件mdn" aria-label="Permalink to &quot;unload事件[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Events/unload)&quot;">​</a></h3><p>当文档或一个子资源正在被卸载时, 触发 unload事件。</p><p>它在下面两个事件后被触发:</p><ol><li>beforeunload (可取消默认行为的事件)</li><li>pagehide</li></ol><h2 id="_2-请求发送" tabindex="-1">2.请求发送 <a class="header-anchor" href="#_2-请求发送" aria-label="Permalink to &quot;2.请求发送&quot;">​</a></h2><h3 id="方案1-发送同步的ajax请求" tabindex="-1">方案1: 发送同步的ajax请求 <a class="header-anchor" href="#方案1-发送同步的ajax请求" aria-label="Permalink to &quot;方案1: 发送同步的ajax请求&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var client = new XMLHttpRequest();</span></span>
<span class="line"><span style="color:#e1e4e8;">client.open(&quot;POST&quot;, &quot;/log&quot;, false); // 第三个参数表明是同步的 xhr</span></span>
<span class="line"><span style="color:#e1e4e8;">client.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=UTF-8&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">client.send(analyticsData);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var client = new XMLHttpRequest();</span></span>
<span class="line"><span style="color:#24292e;">client.open(&quot;POST&quot;, &quot;/log&quot;, false); // 第三个参数表明是同步的 xhr</span></span>
<span class="line"><span style="color:#24292e;">client.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=UTF-8&quot;);</span></span>
<span class="line"><span style="color:#24292e;">client.send(analyticsData);</span></span></code></pre></div><p>这种方式虽然有效，但是用户需要等待请求结束才可以关闭页面。对用户的体验不好。</p><h3 id="方案2-使用navigator-sendbeacon发送异步请求" tabindex="-1">方案2：使用navigator.sendBeacon发送异步请求 <a class="header-anchor" href="#方案2-使用navigator-sendbeacon发送异步请求" aria-label="Permalink to &quot;方案2：使用navigator.sendBeacon发送异步请求&quot;">​</a></h3><p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon" target="_blank" rel="noreferrer">MDN</a>的介绍：</p><blockquote><p>这个方法主要用于满足统计和诊断代码的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。然而，对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在 unload 事件处理器中产生的异步 XMLHttpRequest。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">navigator.sendBeacon(url [, data]);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">navigator.sendBeacon(url [, data]);</span></span></code></pre></div><p>data 参数是将要发送的 ArrayBufferView 或 Blob, DOMString 或者 FormData 类型的数据。</p><p>注：</p><blockquote><ul><li>只能发送post请求</li><li>sendBeacon中Content-Type标头唯一允许的值是： * application/x-www-form-urlencoded * multipart/form-data * text/plain</li></ul></blockquote><p>我收集的是提取传输数据的内容类型，并将其设置为HTTP请求的Content-Type。</p><ol><li>如果发送Blob对象，则Content-Type将成为Blob的类型。</li><li>如果发送FormData对象，则Content-Type将变为multipart / form-data</li><li>如果发送了URLSearchParams对象，则Content-Type将变为application / x-www-form-urlencoded</li><li>如果发送普通字符串，则Content-Type变为text / plain</li></ol><p><a href="http://usefulangle.com/post/63/javascript-navigator-sendbeacon-set-form-http-header" target="_blank" rel="noreferrer">可以在此处找到</a>实现不同对象的Javascript代码</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var data = {</span></span>
<span class="line"><span style="color:#e1e4e8;"> name: &#39;test&#39;,</span></span>
<span class="line"><span style="color:#e1e4e8;"> uniqueId: Math.random()</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">var blob = new Blob([JSON.stringify(data)], {type : &#39;application/json&#39;});</span></span>
<span class="line"><span style="color:#e1e4e8;">navigator.sendBeacon(&#39;http://example.in/data/post&#39;, blob);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var data = {</span></span>
<span class="line"><span style="color:#24292e;"> name: &#39;test&#39;,</span></span>
<span class="line"><span style="color:#24292e;"> uniqueId: Math.random()</span></span>
<span class="line"><span style="color:#24292e;">};</span></span>
<span class="line"><span style="color:#24292e;">var blob = new Blob([JSON.stringify(data)], {type : &#39;application/json&#39;});</span></span>
<span class="line"><span style="color:#24292e;">navigator.sendBeacon(&#39;http://example.in/data/post&#39;, blob);</span></span></code></pre></div><p>报错：Uncaught DOMException: Failed to execute &#39;sendBeacon&#39; on &#39;Navigator&#39;: sendBeacon() with a Blob whose type is not any of the CORS-safelisted values for the Content-Type request header is disabled temporarily. See <a href="http://crbug.com/490015" target="_blank" rel="noreferrer">http://crbug.com/490015</a> for details.<br> Chrome <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=490015" target="_blank" rel="noreferrer">https://bugs.chromium.org/p/chromium/issues/detail?id=490015</a>中的安全问题</p><p>解决： 最后我将数据发送为&#39;text / plain; charset = UTF-8&#39;并在服务器端读取流以获取json内容。</p><p>web：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">const blob = new Blob([JSON.stringify(myData)], {type: &#39;text/plain; charset=UTF-8&#39;});</span></span>
<span class="line"><span style="color:#e1e4e8;">navigator.sendBeacon(appData.ReleaseSessionUrl, blob);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">const blob = new Blob([JSON.stringify(myData)], {type: &#39;text/plain; charset=UTF-8&#39;});</span></span>
<span class="line"><span style="color:#24292e;">navigator.sendBeacon(appData.ReleaseSessionUrl, blob);</span></span></code></pre></div><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><p>如何在 Web 关闭页面时发送 Ajax 请求</p><p><a href="https://juejin.im/post/5c7e541b6fb9a049e06415a5" target="_blank" rel="noreferrer">https://juejin.im/post/5c7e541b6fb9a049e06415a5</a></p>`,33),l=[o];function p(r,i,c,d,h,u){return a(),n("div",null,l)}const f=e(t,[["render",p]]);export{g as __pageData,f as default};

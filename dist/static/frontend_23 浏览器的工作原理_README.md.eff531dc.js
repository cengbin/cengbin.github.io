import{_ as e,o as a,c as o,Q as t}from"./chunks/framework.0f4e1e9e.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/23 浏览器的工作原理/README.md","filePath":"frontend/23 浏览器的工作原理/README.md"}'),r={name:"frontend/23 浏览器的工作原理/README.md"},d=t('<h2 id="单进程浏览器时代" tabindex="-1">单进程浏览器时代 <a class="header-anchor" href="#单进程浏览器时代" aria-label="Permalink to &quot;单进程浏览器时代&quot;">​</a></h2><h2 id="浏览器进程与线程" tabindex="-1">浏览器进程与线程 <a class="header-anchor" href="#浏览器进程与线程" aria-label="Permalink to &quot;浏览器进程与线程&quot;">​</a></h2><h3 id="gui渲染线程与js引擎线程互斥" tabindex="-1">GUI渲染线程与JS引擎线程互斥 <a class="header-anchor" href="#gui渲染线程与js引擎线程互斥" aria-label="Permalink to &quot;GUI渲染线程与JS引擎线程互斥&quot;">​</a></h3><p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p><h3 id="js引擎的一些运行机制分析" tabindex="-1">JS引擎的一些运行机制分析 <a class="header-anchor" href="#js引擎的一些运行机制分析" aria-label="Permalink to &quot;JS引擎的一些运行机制分析&quot;">​</a></h3><h4 id="理解一个概念" tabindex="-1">理解一个概念： <a class="header-anchor" href="#理解一个概念" aria-label="Permalink to &quot;理解一个概念：&quot;">​</a></h4><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在<code>主线程（JS引擎线程）</code>上执行，形成一个<code>执行栈</code></li><li>主线程之外，<code>事件触发线程</code>管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放置一个事件。</li><li>主线程之外，<code>定时触发器线程</code>管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放置一个事件。</li><li>一旦<code>执行栈</code>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<code>任务队列</code>，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><h3 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h3><p><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noreferrer">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>',10),c=[d];function i(l,n,s,h,_,u){return a(),o("div",null,c)}const S=e(r,[["render",i]]);export{p as __pageData,S as default};

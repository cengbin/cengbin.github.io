import{_ as o,o as e,c as a,Q as r}from"./chunks/framework.0f4e1e9e.js";const n="/static/20240325130545.fab41a30.jpg",f=JSON.parse('{"title":"Monorepo","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/14 Mono-repo/README.md","filePath":"frontend/14 Mono-repo/README.md"}'),t={name:"frontend/14 Mono-repo/README.md"},p=r('<h1 id="monorepo" tabindex="-1">Monorepo <a class="header-anchor" href="#monorepo" aria-label="Permalink to &quot;Monorepo&quot;">​</a></h1><h2 id="monorepo-介绍" tabindex="-1">Monorepo 介绍 <a class="header-anchor" href="#monorepo-介绍" aria-label="Permalink to &quot;Monorepo 介绍&quot;">​</a></h2><p>Monorepo(monolithic repository) 是一种项目代码管理方式，指单个仓库中管理多个项目，有助于简化代码共享、版本控制、构建和部署等方面的复杂性，并提供更好的可重用性和协作性。</p><h2 id="monorepo-演进" tabindex="-1">Monorepo 演进 <a class="header-anchor" href="#monorepo-演进" aria-label="Permalink to &quot;Monorepo 演进&quot;">​</a></h2><p>阶段一：单仓库巨石应用， 一个 Git 仓库维护着项目代码，随着迭代业务复杂度的提升，项目代码会变得越来越多，越来越复杂，大量代码构建效率也会降低，最终导致了单体巨石应用，这种代码管理方式称之为 Monolith。</p><p>阶段二：多仓库多模块应用，于是将项目拆解成多个业务模块，并在多个 Git 仓库管理，模块解耦，降低了巨石应用的复杂度，每个模块都可以独立编码、测试、发版，代码管理变得简化，构建效率也得以提升，这种代码管理方式称之为 MultiRepo。</p><p>阶段三：单仓库多模块应用，随着业务复杂度的提升，模块仓库越来越多，MultiRepo这种方式虽然从业务上解耦了，但增加了项目工程管理的难度，随着模块仓库达到一定数量级，会有几个问题：跨仓库代码难共享；分散在单仓库的模块依赖管理复杂（底层模块升级后，其他上层依赖需要及时更新，否则有问题）；增加了构建耗时。于是将多个项目集成到一个仓库下，共享工程配置，同时又快捷地共享模块代码，成为趋势，这种代码管理方式称之为 MonoRepo。</p><p><img src="'+n+'" alt=""></p><p>一个简单的monorepo的目录结构类似这样：</p><p>├── packages | ├── pkg1 | | ├── package.json | ├── pkg2 | | ├── package.json ├── package.json ├── lerna.json</p><p>之所以应用monorepo，主要是解决以下问题：</p><ul><li>代码复用的问题</li><li>开发流程统一</li><li>高效管理多项目/包</li></ul><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><p><a href="https://mp.weixin.qq.com/s/kGfNh_yyzGy_F4OkxNlqeA" target="_blank" rel="noreferrer">带你了解更全面的 Monorepo - 优劣、踩坑、选型</a></p>',14),i=[p];function l(s,c,_,h,d,m){return e(),a("div",null,i)}const u=o(t,[["render",l]]);export{f as __pageData,u as default};

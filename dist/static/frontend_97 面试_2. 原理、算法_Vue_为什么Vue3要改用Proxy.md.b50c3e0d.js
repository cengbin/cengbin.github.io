import{_ as o,o as t,c as a,k as e,a as n}from"./chunks/framework.d9e2f5d0.js";const V=JSON.parse('{"title":"为什么Vue3要改用Proxy？","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/97 面试/2. 原理、算法/Vue/为什么Vue3要改用Proxy.md","filePath":"frontend/97 面试/2. 原理、算法/Vue/为什么Vue3要改用Proxy.md"}'),u={name:"frontend/97 面试/2. 原理、算法/Vue/为什么Vue3要改用Proxy.md"};function l(p,r,s,y,d,i){return t(),a("div",null,r[0]||(r[0]=[e("h1",{id:"为什么vue3要改用proxy",tabindex:"-1"},[n("为什么Vue3要改用Proxy？ "),e("a",{class:"header-anchor",href:"#为什么vue3要改用proxy","aria-label":'Permalink to "为什么Vue3要改用Proxy？"'},"​")],-1),e("ol",null,[e("li",null,"可以用Proxy检测对象新添加的属性，让他反应过来。（Vue2+只能通过Vue.set(obj,key,value)来添加新的响应式的属性）。"),e("li",null,"同样是适用于数组对象，（Vue2+改写了Array.prototype,对它做了代理所以当调用array.push,array.pop，改变数据长度等等的方法或操作的时候可以做到视图响应。注意：改变原生对象的prototype是不推荐，且需要谨慎的事情！），使用Proxy代理数组就能够监听到数组的变化。"),e("li",null,"proxy比defineProperty强大了太多，不仅解决了vue的历史难题，让vue的体验更上了一层，更是去除了不少因为defineProperty、Array.prototy代理而必须要的方法，精简了vue的包大小。"),e("li",null,"摆脱Vue目前的警告。（动态给对象添加属性，不用显示的告诉Vue您正在添加属性，你想让它反应过来）")],-1)]))}const c=o(u,[["render",l]]);export{V as __pageData,c as default};

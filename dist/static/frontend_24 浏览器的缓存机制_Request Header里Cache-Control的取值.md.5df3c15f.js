import{_ as e,o as a,c as o,Q as t}from"./chunks/framework.0f4e1e9e.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/24 浏览器的缓存机制/Request Header里Cache-Control的取值.md","filePath":"frontend/24 浏览器的缓存机制/Request Header里Cache-Control的取值.md"}'),c={name:"frontend/24 浏览器的缓存机制/Request Header里Cache-Control的取值.md"},r=t('<h2 id="request-header里cache-control的取值" tabindex="-1">Request Header里Cache-Control的取值 <a class="header-anchor" href="#request-header里cache-control的取值" aria-label="Permalink to &quot;Request Header里Cache-Control的取值&quot;">​</a></h2><h3 id="cache-control-max-age-0" tabindex="-1">Cache-Control:max-age=0 <a class="header-anchor" href="#cache-control-max-age-0" aria-label="Permalink to &quot;Cache-Control:max-age=0&quot;">​</a></h3><p>这个值表示，这个请求按照协商缓存的规则走，一定会发出真实的请求。这里和响应头里的max-age=0有不同</p><h3 id="cache-control-no-cache" tabindex="-1">Cache-Control:no-cache <a class="header-anchor" href="#cache-control-no-cache" aria-label="Permalink to &quot;Cache-Control:no-cache&quot;">​</a></h3><p>这个值一般会附带Pragma: no-cache，是为了兼容http1.0。表示这次请求不会读缓存资源，即便缓存没有过期，或者资源并没有修改，这样的请求不会有返回304的可能。这一点和响应头里的Cache-Control:no-cache是有区别的。 Request Header里Cache-Control只有这两个值可取，设置其他的值无效，比如设置Cache-Control:no-store是没有用的，这一点要和响应头里的Cache-Control区分开。 Request Header里的Cache-Control只有在浏览器刷新，硬性重新加载。这两种浏览器自己的行为中会被添加。 如果是一个常规的，设置了协商缓存（响应头里Cache-Control:no-cache），和不缓存（响应头里Cache-Control:no-cache）的请求，它在正常的，通过上文方式1访问时，是不会在请求头里添加Cache-Control值的。</p>',5),n=[r];function h(l,s,C,d,_,i){return a(),o("div",null,n)}const p=e(c,[["render",h]]);export{m as __pageData,p as default};

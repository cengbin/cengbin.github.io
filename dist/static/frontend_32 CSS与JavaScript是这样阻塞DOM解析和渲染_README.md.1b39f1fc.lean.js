import{_ as e,o as s,c as l,O as a}from"./chunks/framework.d9e2f5d0.js";const g=JSON.parse('{"title":"CSS与JS是这样阻塞DOM解析和渲染","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/32 CSS与JavaScript是这样阻塞DOM解析和渲染/README.md","filePath":"frontend/32 CSS与JavaScript是这样阻塞DOM解析和渲染/README.md"}'),o={name:"frontend/32 CSS与JavaScript是这样阻塞DOM解析和渲染/README.md"};function n(c,t,i,r,p,d){return s(),l("div",null,t[0]||(t[0]=[a('<h1 id="css与js是这样阻塞dom解析和渲染" tabindex="-1">CSS与JS是这样阻塞DOM解析和渲染 <a class="header-anchor" href="#css与js是这样阻塞dom解析和渲染" aria-label="Permalink to &quot;CSS与JS是这样阻塞DOM解析和渲染&quot;">​</a></h1><h2 id="css" tabindex="-1">CSS <a class="header-anchor" href="#css" aria-label="Permalink to &quot;CSS&quot;">​</a></h2><ol><li><code>&lt;link/&gt;</code>标签下载CSS文件 <strong>不会阻塞DOM解析</strong></li><li><code>&lt;link/&gt;</code>标签下载CSS文件 <strong>阻塞页面渲染</strong><ul><li>这个策略其实很明智的，想象一下，如果没有这个策略，页面首先会呈现出一个原始的模样，待CSS下载完之后又突然变了一个模样。用户体验可谓极差，而且渲染是有成本的。</li></ul></li><li>如果<code>&lt;script/&gt;</code>在<code>&lt;link/&gt;</code>之后， <strong>CSS下载阻塞JS执行</strong>，只有等CSS下载完成后JS才会执行</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;header&gt;</span></span>\n<span class="line"><span style="color:#e1e4e8;">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/sleep3000-common.css&quot;&gt;</span></span>\n<span class="line"><span style="color:#e1e4e8;">    &lt;script src=&quot;/js/logDiv.js&quot;&gt;&lt;/script&gt;</span></span>\n<span class="line"><span style="color:#e1e4e8;">&lt;/header&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;header&gt;</span></span>\n<span class="line"><span style="color:#24292e;">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/sleep3000-common.css&quot;&gt;</span></span>\n<span class="line"><span style="color:#24292e;">    &lt;script src=&quot;/js/logDiv.js&quot;&gt;&lt;/script&gt;</span></span>\n<span class="line"><span style="color:#24292e;">&lt;/header&gt;</span></span></code></pre></div><pre><code>- 仔细思考一下，其实这样做是有道理的，如果脚本的内容是获取元素的样式，宽高等CSS控制的属性，浏览器是需要计算的，也就是依赖于CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行JS。因而造成了之前例子的情况。\n- 所以，看官大人明白为何`&lt;script&gt;`与`&lt;link&gt;`同时在头部的话，`&lt;script&gt;`在上可能会更好了么？之所以是可能，是因为如果`&lt;link&gt;`的内容下载更快的话，是没影响的，但反过来的话，JS就要等待了，然而这些等待的时间是完全不必要的。\n</code></pre><h2 id="javascript" tabindex="-1">JavaScript <a class="header-anchor" href="#javascript" aria-label="Permalink to &quot;JavaScript&quot;">​</a></h2><ol><li><p><code>&lt;script/&gt;</code>标签中的JavaScript代码执行 <strong>阻塞DOM解析</strong>。如果脚本是外部的，那么<strong>解析过程会停止</strong>，直到从网络下载资源完成后再继续。</p><ul><li><p>浏览器并不知道脚本的内容是什么，如果先行解析下面的DOM，万一脚本内全删了后面的DOM，浏览器就白干活了。更别谈丧心病狂的document.write。浏览器无法预估里面的内容，那就干脆全部停住，等脚本执行完再干活就好了。</p></li><li><p>当然，现代的浏览器很聪明，它会“偷看”之后的DOM内容，碰到如<code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>和<code>&lt;img&gt;</code>等标签时，它会帮助我们先行下载里面的资源，不会傻等到解析到那里时才下载。</p></li></ul></li><li><p>浏览器遇到 <code>&lt;script/&gt;</code> 标签时，会触发页面渲染</p><ul><li>每次碰到<code>&lt;script&gt;</code>标签时，浏览器都会渲染一次页面。这是基于同样的理由，浏览器不知道脚本的内容，因而碰到脚本时，只好先渲染页面，确保脚本能获取到最新的DOM元素信息，尽管脚本可能不需要这些信息。</li></ul></li></ol><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>综上所述，我们得出这样的结论：</p><ul><li>CSS下载不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。</li><li>JS 阻塞 DOM 解析，但浏览器会&quot;偷看&quot;DOM，预先下载相关资源。</li><li>浏览器遇到 <code>&lt;script&gt;</code>且没有defer或async属性的 标签时，会触发页面渲染，因而如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕再执行脚本。</li></ul>',10)]))}const u=e(o,[["render",n]]);export{g as __pageData,u as default};

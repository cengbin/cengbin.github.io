import{_ as t,o as e,c as s,Q as r}from"./chunks/framework.0f4e1e9e.js";const g=JSON.parse('{"title":"script标签的async和defer属性","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/详解 之 script 标签 defer async 属性/README.md","filePath":"frontend/详解 之 script 标签 defer async 属性/README.md"}'),a={name:"frontend/详解 之 script 标签 defer async 属性/README.md"},c=r(`<h1 id="script标签的async和defer属性" tabindex="-1">script标签的async和defer属性 <a class="header-anchor" href="#script标签的async和defer属性" aria-label="Permalink to &quot;script标签的async和defer属性&quot;">​</a></h1><p>当浏览器解析DOM过程中遇到<code>&lt;script&gt; ... &lt;/script&gt;</code>内部脚本标签，浏览器不会继续进行DOM解析，它会立刻执行此脚本。对于外部脚本 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续解析DOM。</p><p>这会导致两个重要的问题：</p><ol><li>脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。</li><li>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容：</li></ol><p>幸运的是，这里有两个 <code>&lt;script&gt;</code> 特性（attribute）可以为我们解决这个问题：defer 和 async。</p><p>async和defer属性值为bool，它用来说明script脚本应该<strong>如何执行</strong>。 async和defer属性仅适用于script标签有src属性的情况。在script标签没有src属性的情况下，async和defer属性可以不指定值。</p><p>使用async/defer属性有三种模式可供选择:</p><ol><li><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></li></ol><p>如果async或defer都不存在，那么DOM解析会停止，浏览器会立即加载并执行指定的脚本。执行完成后再继续DOM解析。</p><ol start="2"><li><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></li></ol><p>async 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。async 脚本就是一个会在加载完成时执行的完全独立的脚本。</p><ol start="3"><li><code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></li></ol><p>defer 特性告诉浏览器不要等待脚本加载和执行。浏览器将继续解析DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。</p><p>换句话说：</p><p>具有 defer 特性的脚本不会阻塞页面。 具有 defer 特性的脚本总是要等到 DOM 解析完毕，但在 DOMContentLoaded 事件之前执行。</p><h4 id="具有-defer-特性的脚本保持其相对顺序-就像常规脚本一样。" tabindex="-1">具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。 <a class="header-anchor" href="#具有-defer-特性的脚本保持其相对顺序-就像常规脚本一样。" aria-label="Permalink to &quot;具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。&quot;">​</a></h4><p>假设，我们有两个具有 defer 特性的脚本：long.js 在前，small.js 在后。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;script defer src=&quot;https://javascript.info/article/script-async-defer/long.js&quot;&gt;&lt;/script&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;script defer src=&quot;https://javascript.info/article/script-async-defer/small.js&quot;&gt;&lt;/script&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;script defer src=&quot;https://javascript.info/article/script-async-defer/long.js&quot;&gt;&lt;/script&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;script defer src=&quot;https://javascript.info/article/script-async-defer/small.js&quot;&gt;&lt;/script&gt;</span></span></code></pre></div><p>浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。因此，在上面的示例中，两个脚本是并行下载的。small.js 可能会先下载完成。</p><p>……但是，defer 特性除了告诉浏览器“不要阻塞页面”之外，还可以确保脚本执行的相对顺序。因此，即使 small.js 先加载完成，它也需要等到 long.js 执行结束才会被执行。</p><p>当我们需要先加载 JavaScript 库，然后再加载依赖于它的脚本时，这可能会很有用。</p><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><ul><li><a href="https://zh.javascript.info/script-async-defer" target="_blank" rel="noreferrer">https://zh.javascript.info/script-async-defer</a></li></ul>`,23),p=[c];function i(l,o,n,d,f,h){return e(),s("div",null,p)}const y=t(a,[["render",i]]);export{g as __pageData,y as default};

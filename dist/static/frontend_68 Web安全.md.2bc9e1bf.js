import{_ as a,o as e,c as s,Q as t}from"./chunks/framework.0f4e1e9e.js";const q=JSON.parse('{"title":"Web 安全","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/68 Web安全.md","filePath":"frontend/68 Web安全.md"}'),n={name:"frontend/68 Web安全.md"},o=t(`<h1 id="web-安全" tabindex="-1">Web 安全 <a class="header-anchor" href="#web-安全" aria-label="Permalink to &quot;Web 安全&quot;">​</a></h1><h2 id="跨源资源共享-cors" tabindex="-1">跨源资源共享 CORS <a class="header-anchor" href="#跨源资源共享-cors" aria-label="Permalink to &quot;跨源资源共享 CORS&quot;">​</a></h2><p>跨源资源共享 (CORS)（或通俗地译为跨域资源共享）是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它 origin（域，协议和端口），使得浏览器允许这些 origin 访问加载自己的资源。</p><p>跨源HTTP请求的一个例子：运行在 <a href="https://domain-a.com" target="_blank" rel="noreferrer">https://domain-a.com</a> 的 JavaScript 代码使用 XMLHttpRequest 来发起一个到 <a href="https://domain-b.com/data.json" target="_blank" rel="noreferrer">https://domain-b.com/data.json</a> 的请求。</p><p>出于安全性，浏览器限制脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">HTTP/1.1 200 OK</span></span>
<span class="line"><span style="color:#e1e4e8;">Date: Mon, 01 Dec 2008 00:23:53 GMT</span></span>
<span class="line"><span style="color:#e1e4e8;">Server: Apache/2</span></span>
<span class="line"><span style="color:#e1e4e8;">Access-Control-Allow-Origin: *</span></span>
<span class="line"><span style="color:#e1e4e8;">Keep-Alive: timeout=2, max=100</span></span>
<span class="line"><span style="color:#e1e4e8;">Connection: Keep-Alive</span></span>
<span class="line"><span style="color:#e1e4e8;">Transfer-Encoding: chunked</span></span>
<span class="line"><span style="color:#e1e4e8;">Content-Type: application/xml</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">[XML Data]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">HTTP/1.1 200 OK</span></span>
<span class="line"><span style="color:#24292e;">Date: Mon, 01 Dec 2008 00:23:53 GMT</span></span>
<span class="line"><span style="color:#24292e;">Server: Apache/2</span></span>
<span class="line"><span style="color:#24292e;">Access-Control-Allow-Origin: *</span></span>
<span class="line"><span style="color:#24292e;">Keep-Alive: timeout=2, max=100</span></span>
<span class="line"><span style="color:#24292e;">Connection: Keep-Alive</span></span>
<span class="line"><span style="color:#24292e;">Transfer-Encoding: chunked</span></span>
<span class="line"><span style="color:#24292e;">Content-Type: application/xml</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">[XML Data]</span></span></code></pre></div><p>本例中，服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被 任意 外域访问。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Access-Control-Allow-Origin: *</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Access-Control-Allow-Origin: *</span></span></code></pre></div><h2 id="跨站脚本攻击-xss" tabindex="-1">跨站脚本攻击 XSS <a class="header-anchor" href="#跨站脚本攻击-xss" aria-label="Permalink to &quot;跨站脚本攻击 XSS&quot;">​</a></h2><p>跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。根据开放式 Web 应用安全项目（OWASP），XSS 在 2017 年被认为 7 种最常见的 Web 应用程序漏洞之一。</p><p>本来缩写其应该是CSS，不过为了避免和CSS层叠样式表 （Cascading Style Sheets）重复，所以在安全领域叫做 XSS。</p><h3 id="攻击方式" tabindex="-1">攻击方式 <a class="header-anchor" href="#攻击方式" aria-label="Permalink to &quot;攻击方式&quot;">​</a></h3><p>存储型 XSS</p><p>注入型脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器上传回并执行。</p><p>反射型 XSS</p><p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。由于浏览器认为这个响应来自&quot;可信任&quot;的服务器，所以会执行这段脚本。</p><p>基于 DOM 的 XSS</p><p>通过修改原始的客户端代码，受害者浏览器的 DOM 环境改变，导致有效载荷的执行。也就是说，页面本身并没有变化，但由于DOM环境被恶意修改，有客户端代码被包含进了页面，并且意外执行。</p><h3 id="防御方式" tabindex="-1">防御方式 <a class="header-anchor" href="#防御方式" aria-label="Permalink to &quot;防御方式&quot;">​</a></h3><h2 id="跨站请求伪造-csrf" tabindex="-1">跨站请求伪造 CSRF <a class="header-anchor" href="#跨站请求伪造-csrf" aria-label="Permalink to &quot;跨站请求伪造 CSRF&quot;">​</a></h2><p>跨站请求伪造（Cross-site request forgery, CSRF）是一种冒充受信任用户，向服务器发送非预期请求的攻击方式。</p><p><strong>举个例子</strong></p><p>这一天，小明同学百无聊赖地刷着Gmail邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意：</p><blockquote><p>甩卖比特币，一个只要998！！</p></blockquote><p>一个典型的CSRF攻击有着如下的流程：</p><p>聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的态度点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生……</p><p>在这平静的外表之下，黑客的攻击已然得手。小明的Gmail中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被自动转发到hacker@hackermail.com。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。</p><p>不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。</p><p>小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;form method=&quot;POST&quot; action=&quot;https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf&quot; enctype=&quot;multipart/form-data&quot;&gt; </span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;input type=&quot;hidden&quot; name=&quot;cf2_emc&quot; value=&quot;true&quot;/&gt; </span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;input type=&quot;hidden&quot; name=&quot;cf2_email&quot; value=&quot;hacker@hakermail.com&quot;/&gt; </span></span>
<span class="line"><span style="color:#e1e4e8;">    .....</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;input type=&quot;hidden&quot; name=&quot;irf&quot; value=&quot;on&quot;/&gt; </span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;input type=&quot;hidden&quot; name=&quot;nvp_bu_cftb&quot; value=&quot;Create Filter&quot;/&gt; </span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/form&gt; </span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;script&gt; </span></span>
<span class="line"><span style="color:#e1e4e8;">    document.forms[0].submit();</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/script&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;form method=&quot;POST&quot; action=&quot;https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf&quot; enctype=&quot;multipart/form-data&quot;&gt; </span></span>
<span class="line"><span style="color:#24292e;">    &lt;input type=&quot;hidden&quot; name=&quot;cf2_emc&quot; value=&quot;true&quot;/&gt; </span></span>
<span class="line"><span style="color:#24292e;">    &lt;input type=&quot;hidden&quot; name=&quot;cf2_email&quot; value=&quot;hacker@hakermail.com&quot;/&gt; </span></span>
<span class="line"><span style="color:#24292e;">    .....</span></span>
<span class="line"><span style="color:#24292e;">    &lt;input type=&quot;hidden&quot; name=&quot;irf&quot; value=&quot;on&quot;/&gt; </span></span>
<span class="line"><span style="color:#24292e;">    &lt;input type=&quot;hidden&quot; name=&quot;nvp_bu_cftb&quot; value=&quot;Create Filter&quot;/&gt; </span></span>
<span class="line"><span style="color:#24292e;">&lt;/form&gt; </span></span>
<span class="line"><span style="color:#24292e;">&lt;script&gt; </span></span>
<span class="line"><span style="color:#24292e;">    document.forms[0].submit();</span></span>
<span class="line"><span style="color:#24292e;">&lt;/script&gt;</span></span></code></pre></div><blockquote><p>这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“hacker@hackermail.com”。</p></blockquote><blockquote><p>小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。</p></blockquote><blockquote><p>黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。</p></blockquote><p>明很快打开Gmail，找到了那条过滤器，将其删除。然而，已经泄露的邮件，已经被转让的域名，再也无法挽回了……</p><p>以上就是小明的悲惨遭遇。而“点开一个黑客的链接，所有邮件都被窃取”这种事情并不是杜撰的，此事件原型是2007年Gmail的CSRF漏洞：</p><p><a href="https://www.davidairey.com/google-gmail-security-hijack" target="_blank" rel="noreferrer">https://www.davidairey.com/google-gmail-security-hijack</a></p><p>当然，目前此漏洞已被Gmail修复，请使用Gmail的同学不要慌张。</p><h3 id="攻击方式-1" tabindex="-1">攻击方式 <a class="header-anchor" href="#攻击方式-1" aria-label="Permalink to &quot;攻击方式&quot;">​</a></h3><p><strong>几种常见的攻击类型</strong></p><ol><li>GET类型的CSRF</li></ol><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：</p><p><code> ![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker)</code></p><p>在受害者访问含有这个img的页面后，浏览器会自动向<a href="http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker%E5%8F%91%E5%87%BA%E4%B8%80%E6%AC%A1HTTP%E8%AF%B7%E6%B1%82%E3%80%82" target="_blank" rel="noreferrer">http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次HTTP请求。</a></p><ol start="2"><li>POST类型的CSRF</li></ol><p>这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"> &lt;form action=&quot;http://bank.example/withdraw&quot; method=POST&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;xiaoming&quot; /&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot; /&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/form&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"> &lt;form action=&quot;http://bank.example/withdraw&quot; method=POST&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;xiaoming&quot; /&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot; /&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/form&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span></span></code></pre></div><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p><p>3.链接类型的CSRF</p><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;a href=&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot; taget=&quot;_blank&quot;&gt;重磅消息！！&lt;a/&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;a href=&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot; taget=&quot;_blank&quot;&gt;重磅消息！！&lt;a/&gt;</span></span></code></pre></div><p>由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。</p><p><strong>CSRF的特点</strong></p><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</p><h3 id="防御方式-1" tabindex="-1">防御方式 <a class="header-anchor" href="#防御方式-1" aria-label="Permalink to &quot;防御方式&quot;">​</a></h3><p>上文中讲了CSRF的两个特点：</p><ul><li>CSRF（通常）发生在第三方域名。</li><li>CSRF攻击者不能获取到Cookie等信息，只是使用。</li></ul><p>针对这两点，我们可以专门制定防护策略，如下：</p><ul><li>阻止不明外域的访问 <ul><li>同源检测 <ul><li>Samesite Cookie</li></ul></li></ul></li><li>提交时要求附加本域才能获取的信息 <ul><li>CSRF Token <ul><li>双重Cookie验证</li></ul></li></ul></li></ul><h3 id="历史案例" tabindex="-1">历史案例 <a class="header-anchor" href="#历史案例" aria-label="Permalink to &quot;历史案例&quot;">​</a></h3><p><strong>Gmail的CSRF漏洞</strong></p><p>2007年Gmail的CSRF漏洞。</p><p><strong>YouTube的CSRF漏洞</strong></p><p>2008年，有安全研究人员发现，YouTube上几乎所有用户可以操作的动作都存在CSRF漏洞。</p><p><strong>WordPress的CSRF漏洞</strong></p><p>2012年3月份，WordPress发现了一个CSRF漏洞，影响了WordPress 3.3.1版本，WordPress是众所周知的博客平台，该漏洞可以允许攻击者修改某个Post的标题，添加管理权限用户以及操作用户账户，包括但不限于删除评论、修改头像等等。</p><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><p><a href="https://www.cnblogs.com/papering/p/15923917.html" target="_blank" rel="noreferrer">前端安全系列（二）：如何防止CSRF攻击？</a></p>`,68),l=[o];function p(i,c,r,u,d,h){return e(),s("div",null,l)}const g=a(n,[["render",p]]);export{q as __pageData,g as default};

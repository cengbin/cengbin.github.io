## Promise内部实现原理

一个 promise 代表一个异步操作的最终结果。主要的操作方式是通过调用 promise 的 then 方法，它接受的回调函数接受 promise 成功的结果或失败的原因。

一个 promise 有且只有一个状态（pending，fulfilled，rejected 其中之一）。

从创建一个实例开始,如下代码：

```
var promise = new Promise((resolve,reject)=>{
	resolve(1)
}).then((value)=>{
	console.log(value);
},(reason)=>{
	console.log(reason);
})
```

1. 同步执行构造函数，构造函数内部执行过程如下：
	* 判断构造函数参数`executor`是否是函数。不是则抛出错误异常。
	* 初始化当前状态为pending。
	* 初始化记录fulfilled状态应该执行函数的数组`onFulfilledCallbacks`。
	* 初始化记录rejected状态应该执行函数的数组`onRejectedCallbacks`。
	* 同步执行`executor`函数，并传入`resolve` `reject`函数作为参数。
2. 同步执行promise实例的then函数，then函数内部执行过程如下：
	* 如果then函数参数onFulfilled/onRejected不是函数，并且当前promise状态已经变了则初始化onFulfilled、onRejected函数。
	* 根据规范then函数应该返回一个Promise实例，所以接下来是创建一个Promise实例`let promise2 = new PromiseA((resolve, reject) => { ... })`。
		* 如果当前promise状态是`fulfilled`状态则异步执行`onFulfilled`函数。
		* 如果当前promise状态是`rejected`状态则异步执行`onRejected`函数。
		* 如果当前promise状态是`pengding`状态则执行：
			* 往`onFulfilledCallbacks`数组添加一个函数。当`promise`实例变成`fulfilled`状态的时候会执行数组中的函数。
			* 往`onRejectedCallbacks`数组添加一个函数。当`promise`实例变成`rejected`状态的时候会执行数组中的函数。
		* 调用`onFulfilled` `onRejected`函数后需要把返回值`x`透传给下一个then函数中的`onFulfilled` `onRejected`函数。
			* 如果x是Promise实例，则把x的结果返回透传给下一个then函数。
			* 如果x是普通对象 && 有then属性 && then是函数，则执行then函数并把结果透传给下一个then函数。
			* 反之则调用`promise2`对象的`resolve`函数并把`x`透传给下一个then函数。

## 优势

* 解决了回调地狱的问题
* 解决信任问题 what？？？

## 缺点

* 如果Promise内部是一个异步调用，无法知道当前异步调用的状态。
* Promise 无法取消。

# 函数高级内幕

1. 变量作用域
2. 变量提升与函数提升
3. 作用域链
4. 函数的arguments
5. 函数的执行上下文
6. 函数内部执行过程
7. 函数的四种调用模式
8. 没有重载
9. 函数的属性和方法
	* .length
	* .prototype

## 术语
* 栈的数据结构-先进后出
* EC:函数的执行环境（或函数执行上下文），Execution Context（上下文封装了函数前置和后置的相关信息）
* ECS:执行环境栈 ，Execution Content Stack
* VO变量对象（Variable Object）是说JavaScript的执行上下文中都有个对象用来存放执行上下文中可被访问但是不能被delete的函数标示符，形参，变量声明等。它们会被挂在这个对象上。（全局）
* AO激活对象（Activation Object）有了变量对象存每个上下文中的东西，但是它什么时候能被访问到呢？就是每进入一个执行上下文时，这个执行上下文儿中的变量对象就被激活，也就是该上下文中的函数标示符，行参，变量声明等就可以被访问到了。

函数在执行之前创建EC，并且把EC放入到ECS中。当函数执行完成之后EC从ECS中出栈。


## 1. 变量作用域

JavaScript只有全局作用域和函数作用域（没有块级作用域）
for循环，while循环属于块代码，中间定义的变量的作用域是函数级别的作用域。


## 2. 变量提升与函数提升

函数声明提升和变量声明提升

## 3. 作用域链

* 作用域链是一个数组
* 作用域链是控制变量作用域的有序访问的js内部实现。
* 作用域链存储在函数的执行上下文中，作用域链中存放的是执行环境中的vo或者ao。
* 当前函数的作用域对象都都是在最前端，而且全局的在最末端
* 变量（标识符）的搜索都是从作用域链的最前端向后搜索，直到全局作用域，标识符的解析是沿着作用域链一级一级搜索的过程，从第一个对象开始，逐级向后惠遡，直到找到同名标识符为止，找到后不再继续遍历，找不到就报错。

## 4. 函数的arguments

## 5. 函数的执行上下文

函数执行上下文的生命周期：创建 -> 执行 -> 出栈

* 创建：

	1. 作用域链 scope chain
	2. 变量对象 Varible Object & ao（局部）
	    1. 初始化函数的参数arguments
	    2. 初始化函数的声明（函数的优先级要高于变量，如果变量和函数重名，变量会被忽略）
	    3. 初始化变量
	3. this指向

* 执行：JavaScript 的解释和执行
* 出栈

## 6. 函数内部执行过程

## 7. 函数的四种调用模式

* 函数调用
* new 构造函数调用
* call 
* applay 

## 8. 没有重载

判断Argument.length 模拟函数重载

## 9. 函数的属性和方法

## 函数式编程

* 数组的sort方法
* 数组的map方法（IE9+支持）
* 数组的forEach方法（IE9+支持） 

## 原型链

* 函数的原型对象(`.prototype`)
* 原型对象的构造函数(`.constructor`)
* 内部原型(`.__proto__`) 